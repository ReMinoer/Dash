< Title > Dash Language Documentation
< Subtitle > Documents Advanced Syntax by Highlighting

~~~~
To-Do

- Multiple paragraph lists
- Rewrite code snippets and examples
~~~~

<-> Identity

This language is called Dash. His name come from the multiples definition of the word :

- Dash as the name for the ""character"" {-}, used a lot in the language.
- Dash as a ""fast"" movement, corresponding to a quick-note language.
- Dash as a small amount of something, giving the idea of ""subtility"" and ""optimization"".
- Dash as the action of ""destroy"", with one target : the //Markdown// language.

Used file extensions are:

- .dh : two character extension
- .dash : name extension

Majuscule extensions are also tolerated.

<-> Paragraphs

You can write paragraphs directly.

Jump two lines to write another paragraphs.
You can also back to the line in the same paragraph.

< .dash- >
{
    You can write paragraphs directly.

    Jump two lines to write another paragraphs.
    You can also back to the line in the same paragraph.
}

< Design note >
Come back to the line in the same paragraph is handled in the language because it's a common plain text formatting.

<-> Decoration

You can use ""bold"" with { "" ... "" }.
You can use //italic// with { // ... // }.
You can use __underline__ with { __ ... __ }.
You can use ==strikethrough== with { == ... == }.

< Design note >
These symbols have been choosen because they are simple to access on a keyboard, refers to their effects and highlight plain text at different degrees.

You can use all these decoration at the same time if you want. You just need to think to always close the last opened decoration before the others: **//__Here__ is an ==exemple==.//**

< .dash- >
{
     ""//__Here__ is// an ==exemple=="".
}

< Design note >
These 4 characters can be used in text if they are not double. For example, "4 * 3 / 2 = _ ?" will be parsed normally.

<-> Lists

You can list items by using { - } at the beginning of lines.

-Item A
-Item B
-Item C

< .dash- >
{
    -Item A
    -Item B
    -Item C
}

You can describe trees by breaking the alignement with tabulations or spaces.

- Item A
    - Sub-item A1
        - Sub-sub-item A1a
    - Sub-item A2
        - Sub-sub-item A2a
        - Sub-sub-item A2b
- Item B
    - Sub-item B1
        - Sub-sub-item B1a
        - Sub-sub-item B1b

< .dash- >
{
    - Item A
        - Sub-item A1
            - Sub-sub-item A1a
        - Sub-item A2
            - Sub-sub-item A2a
            - Sub-sub-item A2b
    - Item B
        - Sub-item B1
            - Sub-sub-item B1a
            - Sub-sub-item B1b
}

< Design note >
In Dash, a tabulation is equal to 4 spaces.

You can also create numbered lists with { 1- 2- 3- }.

1- Item 1
2- Item 2
3- Item 3

< .dash- >
{
    1- Item 1
    2- Item 2
    3- Item 3
}

< Design note >
Numbers used and order is not important. You can put { 1- } on each line if you want. It must just begin by a number. 

If you don't want to use numbers and leave the order to the parser, use { $- }

$- Item 1
$- Item 2
$- Item 3

< .dash- >
{
    $- Item 1
    $- Item 2
    $- Item 3
}

< Design note >
In Dash, { $ } replace numbers when it's possible.

You can combine all these types of lists on different levels if you want.

1 - Item 1
    - Sub - item A
    - Sub - item B
2 - Item 2
    $ - Sub - item A
    $ - Sub - item B

< .dash- >
{
    1 - Item 1
        - Sub - item A0
        - Sub - item B
    2 - Item 2
        $ - Sub - item A
        $ - Sub - item B
}

<-> Links

You can put external links in your note by using { [content][adress] }.
Here is an example : [Link text][http://www.google.com/]

< .dash- >
{
    [Link text][http://www.google.com/]
}

If you also want to use the adress as text, use { [[adress]] } like so: [[http://www.google.com/]]

< .dash- >
{
    [[http://www.google.com/]]
}

<-> Targets

You can define internal target at a specific position in your document with { @[identifier] }.

< .dash- >
{
    @[First target]
}

Then, you can use that same identifier as adress for a link. For example: [Link text][target]

@[target]
< Design note >
Internal target identification will ignore the case.

It's also possible to use multiple identifier for a same target by separate them with pipes { | }.

< .dash- >
{
    @[First target | 1st target]
}

< Design note >
You can build a lexic by combining multi-identifier targets and raw internal links.

< .dash- >
{
    [[Dash]] stands for "[Documents Advanced Syntax by Highlighting][Dash]".
    ...
    @[dash]
    Dash: wonderful language
}

< Design note >
You can also use [ and ] as text if needed.

<-> Notes

You can write a note on a line beginning by a target with a number or { $ } as identifier. { @[$] }.
Then, it is possible to reference that note with { [content][number] }.

If you use { $ }, the next note not already referenced will be [linked][$].
If you use a number, it will reference the next note in text with [that number][1] or, if it didn't exist, the previous one.

@[$] Here is a first note.
@[1] Here is a second note.

If the note contains only a direct link, it will work as a redirection. You can use that [feature][2] to avoid write a [link][2] path in a paragraph or use the same path twice.

@[2] [[https://www.google.fr/search?q=feature]]

< .dash- >
{
    You can use that [feature][2] to avoid put the [link][2] in a paragraph.
    ...
    @[2] [[https://www.google.fr/search?q=feature]]
}

<-> Titles

To add a title, use { <-> } at the beginning of the line.
You can define subtitles by adding more { - } inside brackets.

< .dash- >
{
    <-> Title 1

    Paragraph of Title 1

    <--> Title 2

    Paragraph of Title 2

    <---> Title 3

    Paragraph of Title 3
}

<-> Blocks

You can also define structural blocks for highlight some paragraphs.

< Message > Here is a message on one line.

< .dash- >
{
    < Code > Here is a quote on one line.
}

< Warning >
Here is a warning on one line.

< .dash- >
{
    < Warning >
    Here is a warning on one line, declared on previous line.
}

< Note >
Here is a note

With multiple paragraphs.
</>

< .dash- >
{
    < Note >
    Here is a note

    With multiple paragraphs.
    </>
}

< Design note >
In fact, titles are blocks. Because there are common in various output format and can be inline, they have there own syntax, combining lists and blocks syntax.

<-> Media

If you want to insert a media (like a picture, a video or a table) or some text written in another language (like a code sample), you must use { { ... } }.
To indicate the type of media, it must be preceed by a header providing the file extension used for this type of media. An extension must begin by a point {.}.

< Design note >
Supported media depend of your converter and its supported format. Anyway, converted file must provide an alternative output if the media can't be displayed, like a link or a summary.

If the media that you want to display is inside a file, just provide the path.

< .dash- >
{
    < .ext > { path/file.ext }
}

If the media can be describe directly in your file with its own language, write it directly.

< .dash- >
{
    < .ext >
    {
        Here_is_another_language_using_underscores_as_spaces.
    }
}

If you don't indicate a file extension or if it is unknown and data isn't binary, media will be displayed as plain text.

You can also use prefix to force the kind of display in ambigous cases :

- {+} will force converter to use its default graphic form
- {-} will force converter to use its default textual form

< .dash- >
{
    {
        ~~ Markdown is a plain-text document language like Dash

        < .md > { # Markdown Title } ~~ Display with converter default representation
        < .md+ > { # Markdown Title } ~~ Display a title in a frame
        < .md- > { # Markdown Title } ~~ Display "# Markdown Title" as Markdown language snippet

        ~~ gitignore is a language containing folder and file paths

        < .gitignore > { folder/.gitignore } ~~ Display content of folder/.gitignore file
        < .gitignore- > { folder/.gitignore } ~~ Display "folder/.gitignore" as gitignore language snippet
    }
}

< Design note >
Try to use understandable languages when you describe directly your media. Dash is a textual language and shouldn't use binary data.

<--> Images

< .jpg > { images/cat }
< .png > { https://www.google.fr/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png }

< .dash- >
{
    < .jpg > { images/cat }
    < .png > { https://www.google.fr/images/branding/googlelogo/2x/googlelogo_color_272x92dp }
}

<--> Videos

< .mp4 > { videos/cat }
< .youtube.com > { LJttZ_Zfiw0 }

< .dash- >
{
    < .mp4 > { videos/cat.mp4 }
    < .youtube.com > { LJttZ_Zfiw0 }
}

<--> Tables

< .csv >
{
    Name;John;Paul;Bob
    Age;22;34;58
    Happy?;Yes;Yes;No
}

< .dash- >
{
    < .csv >
    {
        Name;John;Paul;Bob
        Age;22;34;58
        Happy?;Yes;Yes;No
    }
}

<--> Graphs

< .graph >
{
    S* Start
    --> A
    A* Point A
    -- If µ >= 0 --> B
    -- Else --> C
    B* Point B
    --> E
    C* Point C
    --> E
    E* End
}

< .dash- >
{
    < .graph >
    {
        S* Start
        --> A
        A* Point A
        -- If µ >= 0 --> B
        -- Else --> C
        B* Point B
        --> E
        C* Point C
        --> E
        E* End
    }
}

<--> Code

< .cs- >
{
    public class Program()
    {
        public static void Main()
        {
            Console.WriteLine("Hello world !");
        }
    }
}

< .dash- >
{
    < .cs- >
    {
        public class Program()
        {
            public static void Main()
            {
                Console.WriteLine("Hello world !");
            }
        }
    }
}

<-> Comments

You can use comments by using { ~~ } at the beginning of a line.

~~ Comment on one line

< Design note >
{ ~~ } is used as a double character token because { ~ } key doesn't input when you press it once.

For multiline comments, use { ~~~~ ... ~~~~ }.

~~~~
Comment
on multiple lines
~~~~

< Design note >
Some document output format can handle comments so they are not always ignoring.